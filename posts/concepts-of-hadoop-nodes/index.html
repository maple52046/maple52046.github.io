<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Hadoop SecondaryNameNode 、CheckpointNode 與 Backup Node 觀念整理 - 世界的盡頭</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="為了要管理 lab 裡的 Hadoop cluster，針對 Hadoop 的 NameNode、SecondaryNameNode、CheckpointNode 與 BackupNode 做個了survay。
NameNode
Hadoop 的 metadata 是存放在運行 Namenode 的 server 的 memory 裡面，而 Namenode 的工作就是將 clients 對 metadata 的讀寫修改紀錄在edits裡。
當 Namenode 被啟動的時候，會先合併 HDFS 上的 fsimage 與 edits，取得完整的 metadata。此時，原本的 fsimage 會被更新。
之後，在 NameNode 運作的期間，client 對 metadata 的 access 還是只會記錄在新的 edits 裡，直到下一次 NameNode restart 的時候，周而復始的更新 fsimage、產生新的 edits。" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Hadoop SecondaryNameNode 、CheckpointNode 與 Backup Node 觀念整理" />
<meta property="og:description" content="為了要管理 lab 裡的 Hadoop cluster，針對 Hadoop 的 NameNode、SecondaryNameNode、CheckpointNode 與 BackupNode 做個了survay。
NameNode
Hadoop 的 metadata 是存放在運行 Namenode 的 server 的 memory 裡面，而 Namenode 的工作就是將 clients 對 metadata 的讀寫修改紀錄在edits裡。
當 Namenode 被啟動的時候，會先合併 HDFS 上的 fsimage 與 edits，取得完整的 metadata。此時，原本的 fsimage 會被更新。
之後，在 NameNode 運作的期間，client 對 metadata 的 access 還是只會記錄在新的 edits 裡，直到下一次 NameNode restart 的時候，周而復始的更新 fsimage、產生新的 edits。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maple52046.github.io/posts/concepts-of-hadoop-nodes/" /><meta property="og:image" content="https://maple52046.github.io/site-thumbnail.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-18T12:10:07+08:00" />
<meta property="article:modified_time" content="2013-11-18T12:10:07+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://maple52046.github.io/site-thumbnail.png" /><meta name="twitter:title" content="Hadoop SecondaryNameNode 、CheckpointNode 與 Backup Node 觀念整理"/>
<meta name="twitter:description" content="為了要管理 lab 裡的 Hadoop cluster，針對 Hadoop 的 NameNode、SecondaryNameNode、CheckpointNode 與 BackupNode 做個了survay。
NameNode
Hadoop 的 metadata 是存放在運行 Namenode 的 server 的 memory 裡面，而 Namenode 的工作就是將 clients 對 metadata 的讀寫修改紀錄在edits裡。
當 Namenode 被啟動的時候，會先合併 HDFS 上的 fsimage 與 edits，取得完整的 metadata。此時，原本的 fsimage 會被更新。
之後，在 NameNode 運作的期間，client 對 metadata 的 access 還是只會記錄在新的 edits 裡，直到下一次 NameNode restart 的時候，周而復始的更新 fsimage、產生新的 edits。"/>

	
        <link href="https://maple52046.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://maple52046.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />

	
	

	
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://maple52046.github.io">世界的盡頭</a>
	</div>
	<nav>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Hadoop SecondaryNameNode 、CheckpointNode 與 Backup Node 觀念整理</h1>
			<div class="meta">Posted on Nov 18, 2013</div>
		</div>
		

		<section class="body">
			<p>為了要管理 lab 裡的 Hadoop cluster，針對 Hadoop 的 NameNode、SecondaryNameNode、CheckpointNode 與 BackupNode 做個了survay。</p>
<h1 id="namenode">NameNode</h1>
<p>Hadoop 的 metadata 是存放在運行 Namenode 的 server 的 memory 裡面，而 Namenode 的工作就是將 clients 對 metadata 的讀寫修改紀錄在<strong>edits</strong>裡。</p>
<p>當 Namenode 被啟動的時候，會先合併 HDFS 上的 fsimage 與 edits，取得完整的 metadata。此時，原本的 fsimage 會被更新。</p>
<p>之後，在 NameNode 運作的期間，client 對 metadata 的 access 還是只會記錄在新的 edits 裡，直到下一次 NameNode restart 的時候，周而復始的更新 fsimage、產生新的 edits。</p>
<h1 id="secondarynamenode">SecondaryNameNode</h1>
<p>SecondaryNameNode 並不是第二個 NameNode，充其量只是 NameNode 的一個 tool，幫助 NameNode 管理 metadata。</p>
<p>透過上一段我們得知，Namenode 會在每次啟動的時候，將舊的 fsimage 與 edits 整合得到新的 metadata，並更新 fsimage。之後在運作期間的任何修改都是存放在 edits。</p>
<p>因此，<strong>Namenode運作時間越長，理論上來說，下一次啟動 Namenode 的時候，合併資料的時間就會越久</strong>。而 SecondaryNameNode 就是被設計用來解決這個問題。</p>
<p>SecondayNameNode 會定期的向 NameNode 取得最新的 metadata，這期間 NameNode 會停止對 edits 的讀寫，並且將 log 轉入 edits.new 中。然後 SecondaryNameNode 將 edits 與 fsimage 合併，產生一個新的 fsimage。</p>
<p>完成之後，SecondaryNameNode 會將新的 fsimage 傳回 NameNode。當 NameNode 接收到新的 fsimage 之後，會覆蓋掉舊的 fsimage，並刪除舊的 edits，然後將 edits.new 重新命名為 edit。</p>
<p>透過這個機制可以使得 edits 的檔案大小限制在一個固定的範圍內，使得 NameNode 在重啟之後，可以快速地完成整合 metadata 與啟動服務。</p>
<p>此外，當 NameNode crash 時，可以利用 SecondaryNameNode 上的 fsimage 進行 recovery。當然，在 SecondaryNameNode 最後一次整併之後的 data 就無可避免地消失了。</p>
<h1 id="checkpointnode">CheckpointNode</h1>
<p>由於 SecondaryNameNode 的名稱令人容易混淆，因此 Hadoop 1.0.4 版之後有考慮以 CheckpointNode 來取而代之。</p>
<p>CheckpointNode 的架構與 SecondaryNameNode 相差無異，惟啟動命令不同:</p>
<pre tabindex="0"><code>hdfs namenode -checkpoint
</code></pre><h1 id="backupnode">BackupNode</h1>
<p>由於 SecondaryNameNode 只有 checkpoint 的功用，因次也具有一些缺點:</p>
<ul>
<li>fsimage 較舊</li>
<li>Multi-SecondaryNameNode 會造成 data 不一致，同時效能也較差</li>
</ul>
<p>因此，新版的 Hadoop(version 2.2) 新增的 BackupNode。</p>
<p>在新版的 Hadoop 中，BackupNode 與 NameNode 擁有相同的資料，並且 NameNode 會將每次對 edits 的讀寫都同步傳給 BackupNode，使得 BackupNode 擁有最新的 metadata。</p>
<hr>
<h1 id="參考資料">參考資料</h1>
<ul>
<li><a href="http://www.656463.com/article/1577">Hadoop Backup Node</a></li>
<li><a href="http://itindex.net/detail/43805-hadoop-secondary-namenode">浅析Hadoop Secondary NameNode，CheckPoint Node，Backup</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html">HDFS Users Guide(Hadoop 1.2.1)</a></li>
<li><a href="http://hadoop.apache.org/docs/r2.2.0/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html#Backup_Node">HDFS Users Guide(Hadoop 2.2.0)</a></li>
</ul>
<ul>
<li><a href="https://www.inkling.com/read/hadoop-definitive-guide-tom-white-3rd/chapter-9/hadoop-configuration">Hadoop Configuration</a></li>
<li><a href="http://book.51cto.com/art/201205/339038.htm">Hadoop的Secondary NameNode方案</a></li>
<li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/04/18/2454693.html">hadoop 根据SecondaryNameNode恢复Namenode</a></li>
</ul>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/hadoop">hadoop</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2024  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-GC1G5TJVGY', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</div>
    </body>
</html>
